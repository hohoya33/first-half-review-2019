<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>상반기 리뷰</title>
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css">
		<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
		<link rel='stylesheet' href='lib/font/devicons/devicons.css'>
		<style type="text/css">
		.devicons-javascript{color:#f5de19}
		.devicons-html5{color:#e44f26}
		.devicons-css3{color:#1572b6}
		.devicons-npm{color:#a23332}
		.devicons-sass{color:#cd6799}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<div><img src="img/js_logo.png " alt="" style="width:18%;"></div>
					<h1 style="margin-bottom:100px;font-size:50px;letter-spacing:normal">상반기 리뷰</h1>
					<p>2019. 5. 9</p>
					<p>서비스 개발1팀 UI파트 - 김재호</p>
				</section>

				<section>
					<h2>The Agenda</h2>
					<ul>
						<li>Observer API</li>
						<li>무한 스크롤</li>
						<li>스켈레톤 스크린</li>
					</ul>
				</section>


				<section>
					<section>
						<h2>Observer API</h2>
					</section>


					<section>
						<h2>Observer? 관찰자?</h2>
					</section>


					<section>
						<h2>옵저버 패턴</h2>
						<p>한 객체의 상태가 바뀌면 다른 객체들에게<br>알려주고 자동으로 내용이 갱신되는 방식</p>
						<p>ex. 엑셀 표) 사용자가 스프레드시트 값 변경 → 표, 그래프, 차트 변화<br>이때 모든 요소들이 동시에 즉각적으로 반응</p>
						<div style="width:42%;margin:0 auto;padding:10px 10px 0px;background:#fff"><img src="img/observer.png" alt=""></div>

						<!-- 모든 객체들의 신속한 동기화를 위해서는 데이터를 보유한 주체(Subject)를 여러 객체들이 감시(Observe)하는 방식이 가장 효과적 -->
						<!-- <p>옵저버는 페이지에서 발생하는 어떤 일들을 감시</p> -->
						<!-- 보다 간단하게 옵저버 패턴을 사용할 수 있는 방법은 없을까요?
						강력한 기능이 탑재된 것은 아니지만 이미 자바스크립트가 자체적으로 보유하고 있는 쏠쏠한 옵저버들이 여럿 있습니다. -->
					</section>

					<section>
						<h2>옵저버</h2>
						<p>페이지에서 발생하는 어떤 일들을 감시</p>
					</section>


					<section>
						<h2>setInterval API</h2>
						<!-- <p>이전에는 객체의 속성 변경을 감지하거나 요소가 출력된 것을 감지 하는것은 꽤 어렵거나 비용이 많이 드는 일</p> -->
						<!-- <p>setInterval 매 초마다 값을 모니터링하고 스타일을 변경 한 코드를 작성</p> -->
						<p>일정 시간마다 반복해서 변경사항이 있는지 확인</p>
						<ul>
							<li>정확한 지연시간을 보장해 주지 않음</li>
							<li>여러 개의 타이머 사용 시 웹 사이트 성능 저하 원인</li>
							<li>메모리 절약을 위해 더 이상 필요하지 않을 때 취소시키는 것이 중요</li>
						</ul>

						<!-- 일반적으로 setInterval은 지정한 시간을 무한 루프 돌리게 된다
						잘못쓰게 되면 무한 루프들이 중복되어 사이트가 느려지는 병목현상이 발생
						이런걸 방지 하기 위해서는 정확하게 한 변수에 setInterval을 정의 하고 이 변수를 clearInterval
						해줘야된다 -->

						<pre><code class="js">
var timeId = setInterval(function() {
	//...
}, 5000); // 5초 마다 실행

clearInterval(timeId);
                        </code></pre>
					</section>

					<section>
						<p>보다 간단하게 옵저버 패턴을 사용할 수 있는 방법은 없을까?</p>
					</section>


					<section>
						<h2>JS Observers</h2>
						<!-- <p>최신 브라우저에서 제공하는 옵저버 목록</p> -->
						<h4>DOM 정보를 관찰 할 수 있는 옵저버</h4>
						<ul>
							<li>MutationObserver - 엘리먼트의 변경 사항 감시</li>
							<li>IntersectionObserver - 뷰포트와 대상 엘리먼트의 교차 감시</li>
							<li>ResizeObserver - 엘리먼트의 너비, 높이 변화 감시</li>
						</ul>
						<h4 style="margin-top: 40px">성능 측정, 코드 상태를 파악하기 위한 옵저버</h4>
						<ul>
							<li>PerformanceObserver - 웹 성능 측정 데이터를 효율적으로 액세스</li>
							<li>ReportingObserver - 웹 사이트의 잠재적인 문제를 발견하면 리포팅</li>
						</ul>
					</section>

<!--
					<section>
						<h2>Observers 코드 구조</h2>

						<pre><code class="js">
//객체를 인스턴스화 하고 객체 생성자에 이벤트 핸들러 함수를 전달
var observer = new YOUR-TYPE-OF-OBSERVER(function (entries) {
  // entries: 관찰되는 엘리먼트들의 배열
  entries.forEach(entry => {
      // 각 특정 엔트리를 사용하는 코드 작성
  });
});

// 옵저버에게 지금 무엇을 관찰하는지 알린다.
observer.observe(WHAT-TO-OBSERVE);
                        </code></pre>
					</section>
 -->

					<section>
						<h2>MutationObserver</h2>
						<p>DOM 요소의 변경 사항을 감시하는 API<br>(노드가 새로 추가되거나 제거, 속성, 텍스트 내용)</p>
					</section>


					<section>
						<h2>다국어 프로젝트</h2>
						<ul>
							<li>구글 웹 사이트 번역기 사용</li>
							<li>개발 시 필요한 API 지원이 안되는 문제</li>
							<li>언어 변경 후, 변역이 완료되면<br>다국어 처리(i18n), 페이지 새로고침을 위한 callback 함수 필요</li>
							<!-- <li>번역 시 자식노드에 font 태그 생성</li> -->
						</ul>
						<!-- 상태, 구글 웹 사이트 번역기 언어 변경  =>  DOM 변형 감지  => callback 함수 변경된 언어 전달 (새로고침) -->
						<p>특정 엘리먼트를 감시하고 있다가 변경 사항이 있으면<br>이전 텍스트와 현재 텍스트 비교</p>
						<p>언어 변경 체크를 위해 setInterval 대신 Mutation Observer API 사용</p>
					</section>


					<section>
						<h2>사용 방법</h2>
						<p>MutationObserver 인스턴스 생성<br>변경사항이 발생할 때 마다 실행 될 콜백함수 전달</p>
						<ul>
							<li>observe - 감시 시작 (감시할 DOM 노드, 설정)</li>
							<li>disconnect - 변경 사항 감시 중지</li>
							<li>takeRecords - 콜백으로 처리되기 전에 DOM 변경 사항 반환</li>
						</ul>
						<pre><code class="js">
var observer = new MutationObserver (mutations, observer) => {
	mutations.forEach(mutation => {
		// 변경된 내용 정보
		console.log(mutation);
	});
});
                        </code></pre>
					</section>


					<section>
						<h2>감시 시작</h2>
						<p>감시할 대상과 옵션들을 설정 후 옵저버에 전달</p>
						<pre><code class="js">
// 감시할 대상 선택
var target = document.getElementById('some-element');

// 감시할 옵션
var config = {
	childList: true,
	characterData: true
};

// 모니터링 시작 (감시 대상과 옵션 전달)
observer.observe(target, config);
                        </code></pre>
					</section>


					<section>
						<h2>감시 옵션</h2>
						<p>어떤 내용을 감시할 지에 대한 설정</p>
						<p>childList, attributes, characterData 중 하나 true <br>그렇지 않으면 TypeError 발생</p>
						<pre><code class="js">
var config = {
	childList: true,
	attributes: true,
	characterData: false,
	subtree: false,
	attributeFilter: ['class', 'hidden'],
	attributeOldValue: false,
	characterDataOldValue: false
};
                        </code></pre>
					</section>

					<section>
						<ul>
							<li>childList: 대상 노드 자식 요소 (텍스트 포함)의 추가 및 제거</li>
							<li>attributes: 대상 노드 속성 변경</li>
							<li>characterData: 대상 노드 텍스트 값에 대한 변경 사항</li>
							<li>subtree: 대상 노드 자식 자손까지 모두 감시</li>
							<li>attributeOldValue: 속성 값이 변경 전의 값</li>
							<li>characterDataOldValue: 요소 내부 텍스트를 변경할 경우 이전 값</li>
							<li>attributeFilter: 모든 속성을 관찰 할 필요가 없는 경우 속성명들을 정의</li>
						</ul>
					</section>


					<section>
						<h2>콜백 함수</h2>
						<p>DOM 변경사항 발생 시 처리할 작업</p>

						<pre><code class="js">
var observer = new MutationObserver (mutations, observer) => {
	mutations.forEach(mutation => {
		console.log(mutation);
		// type: 어떤 종류가 변경되었는지 확인 'attributes' || 'childList' || 'characterData'
		// attributeName: 변경된 속성명
		// attributeNamespace: 속성 네임스페이스
		// addedNodes: 추가된 노드
		// removedNodes: 제거된 노드
		// nextSibling: DOM의 다음 형제
		// previousSibling: DOM의 이전 형제
		// oldValue: 속성 또는 데이터 이전 값
		// target: 감시 대상 태그
	});
};
                        </code></pre>
					</section>

<!--
					<section>
						<h2>childList</h2>
						<p>자식 요소에 대한 변경 사항 감시</p>
					</section> -->


					<section>
						<h2>감시 중지</h2>
						<p>작업이 끝난 후 DOM 감시를 중단하기 위해 사용</p>
						<pre><code class="js">
// 변경 사항 감시 중지
observer.disconnect();
                        </code></pre>
					</section>

					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/6prg1kh5/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<h2>placeholder 번역 대응</h2>
						<p>기존 placeholder 값을 임시 DOM 안에 넣은 후 옵저버로 감시</p>
						<p>번역이 완료 되면 placeholder 속성을 변역된 언어로 변경</p>

<!-- 						<pre><code class="js">
$('[placeholder]:not(.translated)').each(function(){
	var welTarget = $(this);
	var sText = welTarget.attr('placeholder');
	welTarget.after('<span class="trans_placeholder blind" data-default-txt="'+ sText +'">'+ sText +'</span>').addClass('translated');

	observer.observe(welTarget.next('.trans_placeholder').get(0), {childList: true});
});

// observer callback
mutation.target.prev('[placeholder].translated').get(0).placeholder = mutation.target.innerText;
                        </code></pre> -->
					</section>


					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/71dsz8ba/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<h2>브라우저 지원</h2>
						<p>지원되지 않는 브라우저 <a href="https://github.com/megawac/MutationObserver.js" target="_blank">Polyfill</a> 사용</p>

						<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=mutationobserver&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="500px"></iframe>
					</section>

					<section>
						<h2>IntersectionObserver</h2>
						<p>뷰포트와 DOM 요소 간의<br>교차하는 부분의 변화를 비동기적으로 감시하는 API</p>
						<p>무한 스크롤 이미지 레이지 로딩 시<br>Scroll Event 대신 IntersectionObserver API를 사용해 최적화</p>

					</section>


					<section>
						<p>특정 요소가 뷰포트 안에 있는지 확인 - Scroll Event</p>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/qcdj04sr/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>



					<section>
						<h2>Scroll Event</h2>

						<ul>
							<li>스크롤 이벤트는 동기적으로 실행 (메인 스레드에 영향)</li>
							<li>스크롤할 때마다 이벤트가 끊임없이 호출</li>
							<li>이러한 문제를 Debouncing, Throttling을 통해 개선</li>
						</ul>
						<pre><code class="js">
$(window).on('scroll', function() {
  // 1. 각 이미지가 현재 뷰포트에 존재하는지 확인 후
  // 2. 이미지 로드
});
                        </code></pre>
					</section>


					<section>
						<p>Debouncing, Throttling<br>스크롤 이벤트 함수 호출 빈도 조정</p>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/m3p2t4ky/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<!-- <h2>뷰포트 안에 존재하는지 확인</h2> -->
						<!-- 스크롤 시 현재 화면에 들어오는 요소마다 위치 체크를 수동으로 계산 -->
						<p>스크롤 시 해당 요소가 화면에 들어왔는지<br>위치 확인을 위해 수동으로 계산</p>
						<img src="img/scroll_visible.png" alt="" width="45%">
					</section>

					<section>
						<p>getBoundingClientRect() 함수를 사용<br>이 함수는 리플로우(레이아웃) 현상이 발생한다는 단점</p>
						<p>리플로우: 노드의 크기, 위치가 변경되어<br>현재 레이아웃의 일부 또는 전체를 다시 계산하는 과정</p>

						<!-- <p>Reflow: DOM 노드의 레이아웃 수치(너비, 높이, 위치 등) 변경 시 영향 받은 모든 노드의(자신, 자식, 부모, 조상) 수치를 다시 계산(Recalculate)<br>렌더 트리를 재 생성 하는 과정</p> -->
						<pre><code class="js">
function isElementInViewport (el) {
  var rect = el.getBoundingClientRect();
  return (
	rect.top >= 0 &&
	rect.left >= 0 &&
	rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
	rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}
                        </code></pre>
					</section>

					<section>
						<p>이러한 모든 배치 관련 계산이 메인 쓰레드에서 수행</p>
						<img src="img/scroll_inview.png" alt="" width="80%">
					</section>

					<section>
						<h2>IntersectionObserver</h2>
						<!-- 대상으로 정한 UI가 특정 영역에 진입하는 시점에 이벤트를 발생하는 역할 -->
						<!-- <p>웹이 발전함에 따라 이러한 변화를 체크하는 것의 필요성이 높아졌고 그래서 나오게 된 API이다.</p> -->

						<p>scroll 이벤트는 여러 브라우저에서 가장 호환성이 좋긴 하지만,</p>
						<p>최신 브라우저는 요소 확인을 IntersectionObserver를 통해<br>더 뛰어난 성능과 효율적인 방식 제공</p>

						<ul>
							<li>대상 요소 위치를 지속적으로 계산할 필요 없음</li>
							<li>대상 요소가 뷰포트에 들어오거나 벗어날 때 콜백 제공</li>
						</ul>

						<!-- <p>scroll 이벤트 접근 방식은 여러 브라우저에서 가장 호환성이 좋긴 하지만, 최신 브라우저는 Intersection Observer API를 통해 요소 확인 작업을 수행하는 더욱 우수하고 효율적인 방식을 제공</p> -->

						<!-- <p>요소가 페이지에 있는 위치를 지속적으로 계산할 필요 없이<br>대상 요소가 뷰포트에 들어오거나 벗어날 때 콜백 실행</p> -->

						<!-- 요소가 뷰포트와 관련된 위치를 추적하기 위해 수행해야 할 작업을 단순화
						모든 계산을 브라우저로 오프로드하는 방법을 제공
						이렇게하면 더 효율적이고 성능이 뛰어난 응용 프로그램을 개발 -->
					</section>



					<section>
						<h2>사용 방법</h2>
						<p>IntersectionObserver 인스턴스 생성<br>화면에 교차할 때 실행 될 콜백함수, 옵션 전달</p>

						<pre><code class="js">
var options = {
	root: null,
	rootMargin: '0px 0px 0px 0px',
	threshold: 0
};

var observer = new IntersectionObserver(callback, options);
                        </code></pre>
					</section>


					<section>
						<h2>감시 옵션</h2>
						<p>교차 지점 설정</p>
						<pre><code class="js">
var options = {
	root: null,
	rootMargin: '0px 0px 0px 0px',
	threshold: 0
};
                        </code></pre>
					</section>

					<section>
						<h2>root</h2>
						<ul>
							<li>교차 영역의 기준이 될 root 엘리먼트</li>
							<li>이 속성을 정의하지 않으면 자동으로 브라우저 뷰포트가 사용</li>
						</ul>
						<img src="img/root.png" alt="" width="90%">
					</section>


					<section>
						<h2>rootMargin</h2>
						<ul>
							<li>root 엘리먼트의 마진값</li>
							<li>교차 영역을 확장 또는 축소</li>
							<li>css margin을 사용하는 방법으로 선언, 축약 가능, px과 %로 표현</li>
						</ul>
						<img src="img/rootMargin.png" alt="" width="90%">
					</section>

					<section>
						<h2>threshold</h2>
						<!-- <p>intersectionRatio에 의해 교차하는 영역의 비율을 얻을 수 있지만 콜백이 불리는 타이밍이 교차 타이밍뿐만은 0%와 100% 등별로 쓸모없는 값 밖에 나오지 않는다. 이 표시가 0(표시되지 않은) 100(모두 표시되는) 중 하나 밖에 없기 때문</p> -->

						<ul>
							<li>callback 이벤트 발생 빈도 조정</li>
							<li>0.0 부터 1.0 사이의 숫자, 이 숫자들로 이루어진 배열</li>
							<!-- <li>callback을 실행시킬 지점</li> -->
							<li>0.5 : 타겟이 root요소 내부에 50% 일 때 callback</li>
							<li>1.0 : 타겟이 root요소 내부에 100% 일 때 callback</li>
						</ul>

						<p>ex) 교차 영역이 20% 변할 때마다 callback<br>threshold: [0, 0.2, 0.4, 0.6, 0.8, 1.0]</p>
						<img src="img/threshold.png" alt="" width="90%">
					</section>

				<section>
						<h2>감시 시작</h2>
						<p>옵저버가 감시 할 수 있도록 해당 요소 전달</p>
						<pre><code class="js">
// 대상 요소는 root 요소의 자식이어야 됨
var target = document.querySelector('#item');
observer.observe(target);


// 여러 대상을 추적해야하는 경우 각 대상을 개별적으로 추가
var images = document.querySelectorAll('.lazy');
images.forEach((el) => {
  observer.observe(el);
});
                        </code></pre>
					</section>

					<section>
						<h2>Methods</h2>
						<dl>
							<dt>observer.observe(targetElement)</dt>
							<dd>타겟 엘리먼트에 대한 IntersectionObserver 등록 (감시 시작)</dd>
							<dt style="margin-top: 20px">observer.unobserve(targetElement)</dt>
							<dd>하나의 대상 요소 감시을 중지하도록 지시</dd>
							<dt style="margin-top: 20px">observer.disconnect()</dt>
							<dd>다수의 엘리먼트를 감시하고 있을 때, 모든 관측을 중지하도록 지시</dd>
							<dt style="margin-top: 20px">observer.takerecords()</dt>
							<dd>교차하는지 여부에 관계없이 모든 감시 대상 목록을 반환</dd>
						</dl>
					</section>

					<section>
						<h2>콜백 함수</h2>
						<p>해당 요소가 화면에 들어오거나 벗어날 때 처리할 작업</p>

						<pre><code class="js">

var callback = (entries, observer) => {
	entries.forEach(entry => {
		// entry는 감지된 엘레멘트의 정보
		if (entry.isIntersecting && entry.intersectionRatio == 1 ) {
			// 타겟이 화면에 들어오면
		} else {
			// 타겟이 화면을 벗어나면
		}
	});
};
                        </code></pre>
					</section>


					<section>
						<h2>entry 객체</h2>
						<dl>
							<dt>- rootBounds</dt>
							<dd>root 엘리먼트 정보</dd>
							<dt>- boundingClientRect</dt>
							<dd>target 엘리먼트 정보</dd>
							<dt>- intersectionRect</dt>
							<dd>교차된 영역 정보</dd>
							<dt>- intersectionRatio</dt>
							<dd>교차하는 영역 비율<br>threshold와 같이 0.0 ~ 1.0 값</dd>
							<dt>- isIntersecting</dt>
							<dd>target이 교차 영역에 있으면 true<br>그 외는 false</dd>
							<dt>- target</dt>
							<dd>target 엘리먼트</dd>
							<dt>- time</dt>
							<dd>교차가 기록된 시간</dd>
						</dl>
						<img src="img/callback.png" alt="" width="50%" style="vertical-align:top">
					</section>




					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/xL3jeuy5/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<p>비동기적으로 실행, 메인 스레드에 영향을 주지 않으면서 요소 확인</p>
						<!-- <p>getBoundingClientRect()를 호출한 것과 같은 결과</p> -->
						<p>getBoundingClientRect()를 호출 할 필요 없어 리플로우 현상 방지</p>

						<img src="img/observer_inview.png" alt="" width="80%">
					</section>


					<section>
						<h2>브라우저 지원</h2>
						<p>지원되지 않는 브라우저 <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" target="_blank">Polyfill</a> 사용</p>

						<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=intersectionobserver&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="500px"></iframe>
					</section>

					<section>
						<p>IntersectionObserver가 현재 브라우저에서 사용 가능한지 확인<br>그렇지 않으면 기존 방식 레이지 로딩으로 처리</p>
						<pre><code class="js">
if (!('IntersectionObserver' in window)) {
	Array.from(images).forEach(image => preloadImage(image));
} else {
	observer = new IntersectionObserver(callback, options);
	images.forEach(image => {
		observer.observe(image);
	});
}
                        </code></pre>
					</section>



					<!--
					<section>
						<h2>ResizeObserver</h2>
						<p>DOM 객체의 크기 변화를 감시하는 옵저버</p>
						<p>기기 너비가 일정 픽셀 이하로 줄어들었을 때 콜백 함수를 활용하거나 섬세한 애니메이션을 필요로 할 때 유용</p>
						<p>최신 크롬 환경에서만 지원, 폴리필을 다운받아 사용 추천</p>
					</section>
					-->

				</section>






				<section>
					<section>
						<h2>무한 스크롤</h2>
					</section>

					<!--
					<section>
						<dl>
							<dt>개발 기간</dt>
							<dd>2018. 12 ~ 2019. 03</dd>
							<dt style="margin-top: 40px">서비스 적용범위</dt>
							<dd>PC/MO 특가매장(해바/오반장), 대카테고리</dd>
						</dl>
					</section>
 					-->

					<section>
						<h2>기능 정의</h2>
						<img src="img/dom_recyle.png" alt="" width="70%">
						<ul>
							<li>스크롤이 맨 아래에 도달하면 다음 데이터를 append 하는 방식</li>
							<li>DOM이 계속 쌓이는 형태 → 화면에 보이는 DOM만 유지</li>
							<li>뷰포트 밖 요소를 제거함으로써 성능향상</li>
							<li>뒤로가기(히스토리백) 시 이전 상태 유지</li>
						</ul>
					</section>

					<section>
						<h2>egjs 라이브러리</h2>
						<a href="https://naver.github.io/egjs/" target="_blank"><img src="img/egjs_logo.png" alt="" width="22%"></a>
						<ul>
							<li>네이버에서 제공. 인터랙티브한 컨텐츠를 만드는데 특화된 라이브러리</li>
							<li>Jindo 프레임워크 부터 쌓인 노하우를 바탕으로 개발</li>
							<li>jQuery, React기반</li>
							<li>현재 네이버 쇼핑, 검색, 스포츠등 서비스에 적용</li>
						</ul>
					</section>

					<section>
						<dl>
							<dt><a href="https://naver.github.io/egjs-infinitegrid/" target="_blank">- InfiniteGrid (v3.5.3)</a></dt>
							<dd>레이아웃 유형에 따라 내용을 포함하여 카드 요소를 무한대로 정렬하는데 사용되는 모듈</dd>
							<dt style="margin-top: 40px"><a href="https://naver.github.io/egjs-persist/" target="_blank">- Persist (v2.2.1)</a></dt>
							<dd>히스토리 탐색 중에 지속 된 데이터를 처리하기위한 캐시 인터페이스를 제공</dd>
						</dl>
					</section>


					<section>
						<h2>PC 해피바이러스</h2>
						<p>최대 400개의 상품 → 1000개 상품 대응</p>
						<ul>
							<li>egjs는 IE9부터 지원</li>
							<li>하위 브라우저(IE8)를 어떻게 대응할 것인가?</li>
							<li>스크롤 시 뷰포트의 상품을 체크하는 스크립트, 스크롤이 더 느려지고 버벅거림 성능저하</li>
							<li>DOM이 계속 쌓이는 기존 방식으로 분기처리</li>
						</ul>
					</section>

					<!--
					<section>
						<h2>오픈 후 대응</h2>
						<p>신몰 메인페이지 해피바이러스 영역에서 상품 클릭시 해당 상품 리스트로 이동 (클릭한 상품)</p>

						상단에 대부분 노출 예상
						해당 상품이 나올때까지 데이터를 계속해서 호출

						방법1.
						해당 상품이 페이지 넘버를 파라메터로 넘겨받아 처음 렌더링 시 해당 페이지 부터 노출

						방법2.
						바로 상품상세로 링크 이동

						메인페이지에 노출된 상품이 해피바이러스 매장에 없는 경우도 있음
						2번 방법으로 해결
					</section>
					 -->


					<section>
						<h2>모바일 카테고리</h2>
						<ul>
							<li>PC와 동일하게 작업 진행</li>
							<li>해피바이러스와는 다르게 상품 수가 상당히 많음</li>
							<li>세션스토리지 이슈</li>
							<li>이미지 로딩 이슈</li>
						</ul>
							<!--
							즉 브라우저 프로세스가 사용하는 시스템 메모리 크기에 의존
							로컬스토로지의 경우 브라우저마다 최대 저장용량이 다를 수 있다.
							이런 특징에 기인했는지 최대용량에 대한 언급을 찾을 수 없다.
							브라우저 컨텍스트에서 사용 가능한 시스템의 메모리 크기에 의존하는지 등 -->
					</section>


					<section>
						<h2>세션스토리지 이슈</h2>
						<p>상품 클릭 시 이제까지 추가된 모든 페이지 데이터 저장<br>한 페이지당 80개 상품 * 20 페이지 = 1600개의 상품 정보</p>
						<img src="img/click_save_all_w.png" alt="">
					</section>


					<section>
						<p>세션스토리지(5MB)의 경우 브라우저 프로세스, 메모리 크기에 의존</p>
						<p>10페이지 이후 상품 클릭 시<br>현재 무한 스크롤 리스트 정보를 저장하는데 있어서 에러 발생</p>
						<img src="img/storage_error.png" alt="">
					</section>

					<section>
						<p>클릭한 상품 페이지를 기준으로 위 아래 페이지 데이터만 저장<br>80개 상품 * 최대 3 페이지 = 240개의 상품 정보</p>
						<img src="img/click_save_w.png" alt="">
					</section>


					<section>
						<p>스크롤 시 위 아래로 데이터 추가 가능하도록 대응</p>
						<img src="img/pre_app_w.png" alt="">
					</section>


					<section>
						<h2>이미지 로딩 이슈</h2>
						<p>데이터 요청 시점에 80개의 상품 이미지들 한번에 불러온다는 것</p>
						<p>페이지를 그려낸 뒤에도 연속적으로 네트워크 호출이 발생<br>로딩된 이미지가 배치되면서 리플로우(레이아웃) 발생</p>
						<!-- <p>이미지가 필요한 순간에 불러오도록 개선</p> -->
						<!-- 이미지 로딩 시간 및 상품 이미지들이 추가되기 까지 시간이 올래 걸림 -->
						<!--
						사용자가 스크롤 이동 또는 상품을 좌우 스와이프로 탐색하는 행동을 하는 시점 -->

					</section>


					<section>
						<img src="img/no_lazyloading.png" alt="" width="80%">
					</section>


					<section>
						<h2>지연 로딩 (Lazy Loading)</h2>
						<!-- <p>지연 로딩은 필요한 시점에 실행되도록 동작을 뒤로 미루는 방법</p> -->
						<!-- <p>체감 속도를 향상</p> -->
						<!-- <p>페이지에 보이지도 않는 이미지를 미리 받아둘 필요가 없는 경우<br>이미지를 나중에 로드하는 방법</p> -->
						<p>이미지를 처음부터 불러오는 게 아니라<br>사용자가 스크롤을 해서 이미지 엘리먼트가 화면에 등장하는 순간 로딩 시작</p>
						<p>모든 이미지를 한번에 불러올 필요가 없어 성능 개선 유용</p>
						<p>IntersectionObserver API 사용</p>


						<!-- <p><a href="https://addyosmani.com/blog/lazy-loading/">참고 (네이티브 이미지 레이지 로딩)</a></p> -->
						<!--
						<pre><code class="js">
<img src="celebration.jpg" loading="lazy" alt="..." />
<iframe src="video-player.html" loading="lazy"></iframe>
                        </code></pre>
                    	-->
					</section>

					<section>
						<h2>이미지 지연 로딩 적용한 결과</h2>
						<img src="img/lazyloading.png" alt="" width="80%">
					</section>

					<section>
						<img src="img/no_lazyloading2.png" alt="" width="80%">
						<img src="img/lazyloading2.png" alt="" width="80%">
					</section>


					<!--
					<section>
						<h3>기본 마크업 구조</h3>
						<pre><code class="html">
<div id="_infinite_grid">
	<ul>
		<li data-page="1">
		    <div>test1</div>
		</li>
		<li data-page="1">
		    <div>test2</div>
		</li>
		....
	</ul>
</div>
                        </code></pre>
					</section>


					<section>
						<h3>스크립트</h3>
						<pre><code class="js">
var oInfiniteGrid = new ssg.View.infiniteGrid({
    nEndPage: 30
});

//상품 추가
oInfiniteGrid.on('fetchItems', function(nCurPage) {
	var oSelf = this;
    getMoreItem(nCurPage).done(function(html) {
        var aItems = $($.parseHTML(html)).filter('li.spc_item');
        oSelf.addItemList(aItems);
    }).fail(function(){
    	oSelf.finalData();
    });
});
                        </code></pre>
					</section>


					<section>
						<h3>뒤로가기</h3>
						<pre><code class="js">
var oInfinitePersist = oInfiniteGrid.oPersist;

if (oInfinitePersist.get('') !== null) {
	oInfiniteGrid.historyBack();
} else {
	oInfiniteGrid.firstRender();
}
                        </code></pre>
					</section>
					 -->

				</section>



				<section>
					<section>
						<h2>스켈레톤 스크린</h2>
					</section>

					<section>
						<h2>로딩 인디케이터</h2>
						<!-- <p>웹페이지를 그리기 전, 서버를 거치는 과정에서 유저, 상품, 주문 정보 등<br>데이터를 DB 또는 외부 API 호출</p> -->
						<p>웹 브라우저는 데이터 로딩이 완료될 때까지 대기<br>데이터 로딩 시간이 길어질수록 빈 화면이 노출되거나 현재 페이지에 멈춰있게 됨</p>
						<!-- 따라서 데이터 로딩 시간이 길어질수록 빈 화면이 노출되거나 현재 페이지에 멈춰있게 됩니다. -->
						<!-- <p>사용자에게 기다려 달라는 의미지만 텅빈 화면을 오래 봐야 하는 단점</p> -->
						<img src="img/ssg_loding.png" alt="" width="30%">
					</section>



					<section>
						<h2>스켈레톤 스크린</h2>
						<p>페이지의 뼈대에 해당하는 빈 레이아웃을 먼저 보여주고<br>데이터를 받는 대로 부분적으로 채워가는 방식</p>
						<!-- <p>"덜 지루하게" "좀 더 빨라 보이도록"하는 기법 중 하나</p> -->
					</section>

					<section>
						<p>YouTube, Facebook 화면 로드 상태</p>
						<img src="img/youtebe_facebook.png" alt="" width="65%" style="margin:0">
					</section>


					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/trgsmxbc/embedded/result,js,html,css/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>

					<section>
						<h2>데이터 지연 로딩</h2>
						<!-- 지연이 필요한 영역의 데이터 호출 로직을 서버 controller에서 제거<br> -->
						<p>가장 중요한 UI 영역을 먼저 제공하고,<br>중요도가 떨어지는 영역을 이후 제공, 체감 속도 향상</p>
						<!-- <p>클라이언트 단에서 필요한 시점에 API를 호출하는 방식</p> -->

						<p>자연스러운 UX를 위해 데이터를 가져오는 시간 동안 스켈레톤 스크린 적용</p>
					</section>


					<section>
						<p>IntersectionObserver + Skeleton Screen</p>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/ts3oc01p/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>

				</section>


				<section>
					<h1>감사합니다.</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>