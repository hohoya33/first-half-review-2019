<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>상반기 월간 리뷰</title>
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css">
		<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
		<link rel='stylesheet' href='lib/font/devicons/devicons.css'>
		<style type="text/css">
		.devicons-javascript{color:#f5de19}
		.devicons-html5{color:#e44f26}
		.devicons-css3{color:#1572b6}
		.devicons-npm{color:#a23332}
		.devicons-sass{color:#cd6799}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<div><img src="img/js_logo.png " alt="" style="width:18%;"></div>
					<h1 style="margin-bottom:100px;font-size:50px;letter-spacing:normal">상반기 월간 리뷰</h1>
					<p>2019. 5. 9</p>
					<p>서비스 개발1팀 UI파트 - 김재호</p>
				</section>

				<section>
					<h2>The Agenda</h2>
					<ul>
						<li>Observer API</li>
						<li>무한 스크롤 (InfiniteGrid, Persist)</li>
						<li>스켈레톤 스크린 (Skeleton Screen)</li>
					</ul>
				</section>


				<section>
					<section>
						<h2>Observer API</h2>
					</section>


					<section>
						<h2>옵저버 패턴</h2>
						<p>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게<br>그 정보를 알려주는 디자인 패턴 (일대다 의존성)</p>
						<p>ex) 엑셀 표 - 사용자가 스프레드시트의 값 변경 → 표, 그래프, 차트에도 변화<br>이때 모든 요소들이 동시에 즉각적으로 변화</p>
						<div style="width:42%;margin:0 auto;padding:10px 10px 0px;background:#fff"><img src="img/observer.png" alt=""></div>

						<!-- 모든 객체들의 신속한 동기화를 위해서는 데이터를 보유한 주체(Subject)를 여러 객체들이 감시(Observe)하는 방식이 가장 효과적 -->
						<!-- <p>옵저버는 페이지에서 발생하는 어떤 일들을 감시</p> -->
						<!-- 보다 간단하게 옵저버 패턴을 사용할 수 있는 방법은 없을까요?
						강력한 기능이 탑재된 것은 아니지만 이미 자바스크립트가 자체적으로 보유하고 있는 쏠쏠한 옵저버들이 여럿 있습니다. -->
					</section>

					<section>
						<h2>setInterval API</h2>
						<!-- <p>이전에는 객체의 속성 변경을 감지하거나 요소가 출력된 것을 감지 하는것은 꽤 어렵거나 비용이 많이 드는 일</p> -->
						<p>이전에는 setInterval을 사용하여 변경사항이 발생했는지 반복적으로 실행</p>
						<p>타이머를 동시에 여러 개 사용 시 웹 사이트의 성능을 크게 저하</p>

						<!-- <p>setInterval 매 초마다 값을 모니터링하고 스타일을 변경 한 코드를 작성</p> -->

						<pre><code class="js">
setInterval(function() {
 //...
}, 5000); //5초 마다 실행
                        </code></pre>
					</section>



					<section>
						<h2>JS Observers</h2>
						<p>최신 브라우저에서 제공하는 옵저버</p>
						<ul>
							<li>MutationObserver - 엘리먼트의 속성 변경 감시</li>
							<li>IntersectionObserver - 뷰포트와 대상 엘리먼트의 교차 감시</li>
							<li>ResizeObserver - 엘리먼트의 너비, 높이 변화 감시</li>
							<li>PerformanceObserver - 프로세스 성능 모니터링</li>
							<li>ReportingObserver - 웹 사이트의 표준 및 정책 준수 현황 감시</li>
						</ul>
					</section>

					<!--
					<section>
						<h2>Observers 기본 구조</h2>

						<pre><code class="js">
let observer = new YOUR-TYPE-OF-OBSERVER(function (entries) {
  // entries: 관찰되는 엘리먼트들의 배열
  entries.forEach(entry => {
      // 각 특정 엔트리를 사용하는 코드 작성
  });
});

// 옵저버에게 지금 무엇을 관찰하는지 알린다.
observer.observe(WHAT-TO-OBSERVE);
                        </code></pre>
					</section>
 					-->

					<section>
						<h2>MutationObserver</h2>
						<!-- <p>DOM의 변경 사항을 감지하기 위해 제공하는 웹 API</p> -->

						<p>DOM 요소를 감지하면서 변경 사항이 있을 경우 콜백 실행</p>
						<p>노드가 새로 추가되거나 제거, 속성, 텍스트 내용 변경을 모니터링</p>

						<!-- <ul>
							<li>대상 요소의 속성 변화 감시</li>
							<li>대상 요소의 텍스트 노드 변화 감시</li>
							<li>대상 요소의 자식 노드 변화 감시</li>
							<li>대상 요소의 하위 노드도 감시 대상에 포함</li>
						</ul> -->
					</section>


					<section>
						<h2>다국어 프로젝트</h2>
						<ul>
							<li>무료로 제공되는 구글 웹 사이트 번역기 사용</li>
							<li>개발에 필요한 api가 별도 지원이 안되는 단점</li>
							<li>사용자가 언어 변경 후, 변역이 완료되면 callback 함수 필요</li>
							<!-- <li>번역 시 자식노드에 font 태그 생성</li> -->
							<li>특정 엘리먼트를 감지하고 있다가 변경이 일어나면<br>이전 텍스트와 현재 텍스트 비교</li>
						</ul>
						<!-- 상태, 구글 웹 사이트 번역기 언어 변경  =>  DOM 변형 감지  => callback 함수 변경된 언어 전달 (새로고침) -->
						<p>이때 변경 감지를 위해 setInterval 대신 Mutation Observer API 사용</p>
					</section>


					<section>
						<h2>사용 방법</h2>
						<p>DOM 변경을 감지했을 때 처리할 콜백함수를 가진 옵저버 생성</p>
						<pre><code class="js">
// MutationObserver 인스턴스 만들기
var observer = new MutationObserver(callback);
                        </code></pre>
					</section>


					<section>
						<h2>감시 하기</h2>
						<p>감시할 DOM 요소와 내용을 설정 후 옵저버에 전달</p>
						<pre><code class="js">
// 감시할 DOM 요소
var target = document.getElementById('transObserver');

// 감시할 내용 옵션
var config = {
    childList: true, // 자식요소 font 태그 생성 감지
};

// 모니터링 시작
observer.observe(target, config);
                        </code></pre>
					</section>


					<section>
						<h2>감시할 내용 옵션</h2>
						<ul>
							<li>childList: 대상 노드의 자식 요소 (텍스트 포함)의 추가 및 제거</li>
							<li>attributes: 대상 노드의 속성 변경</li>
							<li>characterData: 대상 노드의 텍스트 값에 대한 변경 사항</li>
							<li>subtree: 대상 노드 및 대상요소의 자식 자손까지 모두 감시</li>
							<li>attributeOldValue: 속성 값이 변경 전의 값</li>
							<li>characterDataOldValue: 요소 내부 텍스트를 변경할 경우 이전 값</li>
							<li>attributeFilter: 모든 속성을 관찰 할 필요가 없는 경우 속성명들을 배열 정의</li>
						</ul>
<!-- 						<pre><code class="js">
var config = {
	childList: 대상 노드의 자식 요소 (텍스트 포함)의 추가 및 제거 관찰
	attributes: 대상 노드의 속성 변경 감시
	characterData: 대상 노드의 텍스트 값에 대한 변경 사항 모니터링
	subtree: 대상 노드 및 대상요소의 자식 자손까지 모두 감시 (childList, attributes 또는 characterData도 true 이어야 함)
	attributeOldValue: 속성 값이 변경 전의 값 (attributes을 true 설정)
	characterDataOldValue: 요소 내부 텍스트를 변경할 경우 이전 값 (characterData가 true 설정)
	attributeFilter: 모든 속성을 관찰할 필요가없는 경우 속성명들을 배열 형태로 정의 예를 들어 ['value']일 경우 해당 요소의 value 값만 바뀔 경우 이벤트 발생
};
                        </code></pre> -->
					</section>


					<section>
						<h2>callback</h2>
<!-- ,
attributeName: null, // 변경된 속성명
attributeNamespace: null, // 변경된 속성네임스페이스
nextSibling: null, // 다음 형제 태그
previousSibling: null, // 이전 형제 태그
oldValue: null, // 변경전 값
removedNodes: [], // 제거된 자식 노드
target: Element, // 대상 태그
type: 'attributes' || 'childList' || 'characterData' // 어떤 종류가 변경되었는지 -->

						<pre><code class="js">
var callback = (mutations, observer) => {
	mutations.forEach(mutation => {
		var newValue, oldValue, language;
		// type: 어떤 종류가 변경되었는지 확인
		// addedNodes: 추가된 자식 노드
		if (mutation.type === 'childList' && mutation.addedNodes.length) {
			// target: 대상 태그
			newValue = mutation.target.innerText;
			oldValue = mutation.target.getAttribute('data-default-txt');

			if (newValue !== oldValue) {
				// 언어변경 callback
			} else if (newValue == oldValue) {
				// 한국어
			}
		}
	});
};
                        </code></pre>
					</section>



					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/6prg1kh5/85/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<h2>placeholder 번역 대응</h2>
						<p>placeholder 값을 가져와 임시 dom 생성 후 옵저버로 감시<br>번역 완료 후, 변경된 언어로 placeholder 변경</p>

						<pre><code class="js">
$('[placeholder]:not(.translated)').each(function(){
	var welTarget = $(this);
	var sText = welTarget.attr('placeholder');
	welTarget.after('<span class="trans_placeholder blind" data-default-txt="'+ sText +'">'+ sText +'</span>').addClass('translated');

	observer.observe(welTarget.next('.trans_placeholder').get(0), {childList: true});
});

// observer callback
mutation.target.prev('[placeholder].translated').get(0).placeholder = mutation.target.innerText;
                        </code></pre>
					</section>


					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/71dsz8ba/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<h2>브라우저 지원</h2>
						<p>지원되지 않는 브라우저 <a href="https://github.com/megawac/MutationObserver.js" target="_blank">Polyfill</a> 사용</p>

						<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=mutationobserver&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="500px"></iframe>
					</section>

					<section>
						<h2>IntersectionObserver</h2>
						<!-- 대상으로 정한 UI가 특정 영역에 진입하는 시점에 이벤트를 발생하는 역할 -->

						<!-- <p>웹이 발전함에 따라 이러한 변화를 체크하는 것의 필요성이 높아졌고 그래서 나오게 된 API이다.</p> -->
						<p>타겟 엘리먼트와 뷰포트가<br>교차하는 부분의 변화를 비동기적으로 관찰하는 API</p>
						<p>무한 스크롤 이미지 레이지 로딩 시 IntersectionObserver API 사용</p>

						<!-- <p>scroll 이벤트 접근 방식은 여러 브라우저에서 가장 호환성이 좋긴 하지만, 최신 브라우저는 Intersection Observer API를 통해 요소 확인 작업을 수행하는 더욱 우수하고 효율적인 방식을 제공</p> -->

						<!-- <p>요소가 페이지에 있는 위치를 지속적으로 계산할 필요 없이<br>대상 요소가 뷰포트에 들어오거나 벗어날 때 콜백 실행</p> -->

						<!-- 요소가 뷰포트와 관련된 위치를 추적하기 위해 수행해야 할 작업을 단순화
						모든 계산을 브라우저로 오프로드하는 방법을 제공
						이렇게하면 더 효율적이고 성능이 뛰어난 응용 프로그램을 개발 -->
					</section>


					<section>
						<h2>기존 scroll 이벤트 문제</h2>
						<p>window에 스크롤 이벤트를 등록하고<br>엘리먼트가 위치에 도달했을 때 실행할 콜백함수 등록</p>
						<ul>
							<li>스크롤 이벤트는 동기적으로 실행되기 때문에 메인 스레드에 영향</li>
							<li>스크롤할 때마다 이벤트가 끊임없이 호출</li>
							<li>Debouncing, Throttling을 통해 이러한 문제 개선</li>
						</ul>
						<pre><code class="js">
$(window).on('scroll', function() {
  //1. 각 이미지가 뷰포트에 존재하는지 확인
  //2. 이미지 로드
});
                        </code></pre>
					</section>


					<section>
						<h2>debounce, throttle</h2>
						<p>스크롤 이벤트 최적화 (함수 호출 빈도 조정)</p>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/m3p2t4ky/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<h2>뷰포트 안에 존재하는지 확인</h2>
						<!-- <p>특정 요소가 뷰포트 안에 있는지 여부를 알아내기 위해</p> -->
						<p>getBoundingClientRect() 함수 사용<br>이 함수는 리플로우, 레이아웃 현상이 발생한다는 단점</p>

						<pre><code class="js">
function isElementInViewport (el) {
  var rect = el.getBoundingClientRect();
  return (
	rect.top >= 0 &&
	rect.left >= 0 &&
	rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
	rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}
                        </code></pre>
					</section>


					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/qcdj04sr/5/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>



					<section>
						<p>스크롤 시 화면에 들어오는 요소마다 위치를 체크해주는 계산을 해야 하며,<br>이러한 모든 배치 관련 계산이 메인 쓰레드에서 수행</p>
						<img src="img/scroll_inview.png" alt="" width="80%">
					</section>


					<section>
						<h2>사용 방법</h2>
						<pre><code class="js">
const options = {
	root: null,
	rootMargin: '0px 0px 0px 0px',
	threshold: 0
};

// 기본구조는 콜백함수와 옵션
const observer = new IntersectionObserver(callback, options);
                        </code></pre>
					</section>


					<section>
						<h2>root</h2>
						<ul>
							<li>교차 영역의 기준이 될 root 엘리먼트</li>
							<li>이 속성을 정의하지 않으면 자동으로 브라우저 뷰포트가 사용</li>
						</ul>
						<img src="img/root.png" alt="" width="80%">
					</section>


					<section>
						<h2>rootMargin</h2>
						<ul>
							<li>root 엘리먼트의 마진값. 이 값에 따라 교차 영역이 확장 또는 축소</li>
							<li>css에서 margin을 사용하는 방법으로 선언, 축약 가능, px과 %로 표현</li>
						</ul>
						<img src="img/rootMargin.png" alt="" width="80%">
					</section>

					<section>
						<h2>threshold</h2>
						<p>이벤트 발생 빈도를 늘리려면 threshold 옵션을 사용</p>
						<!-- <p>intersectionRatio에 의해 교차하는 영역의 비율을 얻을 수 있지만 콜백이 불리는 타이밍이 교차 타이밍뿐만은 0%와 100% 등별로 쓸모없는 값 밖에 나오지 않는다. 이 표시가 0(표시되지 않은) 100(모두 표시되는) 중 하나 밖에 없기 때문</p> -->

						<ul>
							<li>0.0부터 1.0 사이의 숫자 혹은 이 숫자들로 이루어진 배열</li>
							<!-- <li>callback을 실행시킬 지점</li> -->
							<li>1.0이면 root요소 내부에 100% callback</li>
							<li>0.5이면 root요소 내부에 50%일 때 callback</li>
						</ul>

						<p>다음과 같이 인수를 설정하면 교차 영역이 20% 변할 때마다 callback<br>threshold: [0, 0.2, 0.4, 0.6, 0.8, 1.0]</p>
						<img src="img/threshold.png" alt="" width="80%">
					</section>



					<section>
						<h2>callback</h2>
						<p>타겟 엘리먼트가 교차되었을 때 실행 함수 (메인 쓰레드에서 실행)<br>타겟이 화면에 완전히 표시 되면 active 클래스 추가</p>

						<pre><code class="js">

const callback = (entries, observer) => {
	entries.forEach(entry => {
		// entry는 감지된 엘레멘트의 정보
		if (entry.isIntersecting && entry.intersectionRatio == 1 ) {
			entry.target.classList.add('active');
		} else {
			entry.target.classList.remove('active');
		}
	});
};
                        </code></pre>
					</section>


					<section>
						<h2>entry 객체</h2>
						<dl>
							<dt>- rootBounds</dt>
							<dd>root 엘리먼트 정보</dd>
							<dt>- boundingClientRect</dt>
							<dd>target 엘리먼트 정보</dd>
							<dt>- intersectionRect</dt>
							<dd>교차된 영역 정보</dd>
							<dt>- intersectionRatio</dt>
							<dd>교차하는 영역 비율<br>threshold와 같이 0.0 ~ 1.0 값</dd>
							<dt>- isIntersecting</dt>
							<dd>target이 교차 영역에 있으면 true<br>그 외는 false</dd>
							<dt>- target</dt>
							<dd>target 엘리먼트</dd>
							<dt>- time</dt>
							<dd>교차가 기록된 시간</dd>
						</dl>
						<img src="img/callback.png" alt="" width="50%" style="vertical-align:top">
					</section>

					<section>
						<h2>대상 추가</h2>
						<p>일단 관찰자가 만들어지면<br>옵저버가 감시 할 수 있도록 목표 요소를 전달</p>
						<pre><code class="js">
// 대상 요소는 root 요소의 자식이어야 됨
// Single element
const target = document.querySelector('#item');
observer.observe(target);

// 여러 대상을 추적해야하는 경우 각 대상을 개별적으로 추가
// Multiple elements
const images = document.querySelectorAll('.lazy');
images.forEach((el) => {
  observer.observe(el);
});
                        </code></pre>
					</section>

					<section>
						<h2>Methods</h2>
						<dl>
							<dt>observer.observe(targetElement)</dt>
							<dd>타겟 엘리먼트에 대한 IntersectionObserver 등록 (감시 시작)</dd>
							<dt style="margin-top: 20px">observer.unobserve(targetElement)</dt>
							<dd>하나의 대상 요소 감시을 중지하도록 지시</dd>
							<dt style="margin-top: 20px">observer.disconnect()</dt>
							<dd>다수의 엘리먼트를 감시하고 있을 때, 모든 관측을 중지하도록 지시</dd>
							<dt style="margin-top: 20px">observer.takerecords()</dt>
							<dd>교차하는지 여부에 관계없이 모든 감시 대상 목록을 반환</dd>
						</dl>
					</section>


					<section>
						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/xL3jeuy5/3/embedded/result,js/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>


					<section>
						<p>비동기적으로 실행, 메인 스레드에 영향을 주지 않으면서 변경 사항 감시</p>
						<p>getBoundingClientRect()를 호출한 것과 같은 결과</p>
						<!-- <p>getBoundingClientRect() 함수를 호출할 필요가 없어 리플로우 현상을 방지</p> -->

						<img src="img/observer_inview.png" alt="" width="80%">
					</section>


					<section>
						<h2>브라우저 지원</h2>
						<p>지원되지 않는 브라우저 <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" target="_blank">Polyfill</a> 사용</p>

						<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=intersectionobserver&amp;periods=future_1,current,past_1,past_2" frameborder="0" width="100%" height="500px"></iframe>
					</section>

					<section>
						<p>IntersectionObserver가 현재 브라우저에서 사용 가능한지 확인 후<br>그렇지 않으면 기본 동작 사용</p>
						<pre><code class="js">
if (!('IntersectionObserver' in window)) {
	Array.from(images).forEach(image => preloadImage(image));
} else {
	observer = new IntersectionObserver(callback, options);
	images.forEach(image => {
		observer.observe(image);
	});
}
                        </code></pre>
					</section>


					<!--
					<section>
						<h2>ResizeObserver</h2>
						<p>DOM 객체의 크기 변화를 감시하는 옵저버</p>
						<p>기기 너비가 일정 픽셀 이하로 줄어들었을 때 콜백 함수를 활용하거나 섬세한 애니메이션을 필요로 할 때 유용</p>
						<p>최신 크롬 환경에서만 지원, 폴리필을 다운받아 사용 추천</p>
					</section>
					-->

				</section>






				<section>
					<section>
						<h2>무한 스크롤</h2>
					</section>

					<!--
					<section>
						<dl>
							<dt>개발 기간</dt>
							<dd>2018. 12 ~ 2019. 03</dd>
							<dt style="margin-top: 40px">서비스 적용범위</dt>
							<dd>PC/MO 특가매장(해바/오반장), 대카테고리</dd>
						</dl>
					</section>
 					-->

					<section>
						<h2>기능 정의</h2>
						<img src="img/dom_recyle.png" alt="" width="70%">
						<ul>
							<li>스크롤이 맨 아래에 도달하면 다음 데이터를 append 하는 방식</li>
							<li>DOM이 계속 쌓이는 형태 → 화면에 보이는 DOM만 유지</li>
							<li>뷰포트 밖 요소를 제거함으로써 성능향상</li>
							<li>뒤로가기(히스토리백) 시 이전 상태 유지</li>
						</ul>
					</section>

					<section>
						<h2>egjs 라이브러리</h2>
						<a href="https://naver.github.io/egjs/" target="_blank"><img src="img/egjs_logo.png" alt="" width="22%"></a>
						<ul>
							<li>네이버에서 제공. 인터랙티브한 컨텐츠를 만드는데 특화된 라이브러리</li>
							<li>Jindo 프레임워크 부터 쌓인 노하우를 바탕으로 개발</li>
							<li>jQuery, React기반</li>
							<li>현재 네이버 쇼핑, 검색, 스포츠등 서비스에 적용</li>
						</ul>
					</section>

					<section>
						<dl>
							<dt><a href="https://naver.github.io/egjs-infinitegrid/" target="_blank">- InfiniteGrid (v3.5.3)</a></dt>
							<dd>레이아웃 유형에 따라 내용을 포함하여 카드 요소를 무한대로 정렬하는데 사용되는 모듈</dd>
							<dt style="margin-top: 40px"><a href="https://naver.github.io/egjs-persist/" target="_blank">- Persist (v2.2.1)</a></dt>
							<dd>히스토리 탐색 중에 지속 된 데이터를 처리하기위한 캐시 인터페이스를 제공</dd>
						</dl>
					</section>


					<section>
						<h2>PC 해피바이러스</h2>
						<p>최대 400개의 상품 → 1000개 상품 대응</p>
						<ul>
							<li>egjs는 IE9부터 지원</li>
							<li>하위 브라우저(IE8)를 어떻게 대응할 것인가?</li>
							<li>스크롤 시 뷰포트의 상품을 체크하는 스크립트, 스크롤이 더 느려지고 버벅거림 성능저하</li>
							<li>DOM이 계속 쌓이는 기존 방식으로 분기처리</li>
						</ul>
					</section>

					<!--
					<section>
						<h2>오픈 후 대응</h2>
						<p>신몰 메인페이지 해피바이러스 영역에서 상품 클릭시 해당 상품 리스트로 이동 (클릭한 상품)</p>

						상단에 대부분 노출 예상
						해당 상품이 나올때까지 데이터를 계속해서 호출

						방법1.
						해당 상품이 페이지 넘버를 파라메터로 넘겨받아 처음 렌더링 시 해당 페이지 부터 노출

						방법2.
						바로 상품상세로 링크 이동

						메인페이지에 노출된 상품이 해피바이러스 매장에 없는 경우도 있음
						2번 방법으로 해결
					</section>
					 -->


					<section>
						<h2>모바일 카테고리</h2>
						<ul>
							<li>PC와 동일하게 작업 진행</li>
							<li>해피바이러스와는 다르게 상품 수가 상당히 많음</li>
							<li>세션스토리지 이슈</li>
							<li>이미지 로딩 이슈</li>
						</ul>
							<!--
							즉 브라우저 프로세스가 사용하는 시스템 메모리 크기에 의존
							로컬스토로지의 경우 브라우저마다 최대 저장용량이 다를 수 있다.
							이런 특징에 기인했는지 최대용량에 대한 언급을 찾을 수 없다.
							브라우저 컨텍스트에서 사용 가능한 시스템의 메모리 크기에 의존하는지 등 -->
					</section>


					<section>
						<h2>세션스토리지 이슈</h2>
						<p>상품 클릭 시 이제까지 추가된 모든 페이지 데이터 저장<br>한 페이지당 80개 상품 * 20 페이지 = 1600개의 상품 정보</p>
						<img src="img/click_save_all_w.png" alt="">
					</section>


					<section>
						<p>세션스토리지(5MB)의 경우 브라우저 프로세스, 메모리 크기에 의존</p>
						<p>10페이지 이후 상품 클릭 시<br>현재 무한 스크롤 리스트 정보를 저장하는데 있어서 에러 발생</p>
						<img src="img/storage_error.png" alt="">
					</section>

					<section>
						<p>클릭한 상품 페이지를 기준으로 위 아래 페이지 데이터만 저장<br>80개 상품 * 최대 3 페이지 = 240개의 상품 정보</p>
						<img src="img/click_save_w.png" alt="">
					</section>


					<section>
						<p>스크롤 시 위 아래로 데이터 추가 가능하도록 대응</p>
						<img src="img/pre_app_w.png" alt="">
					</section>


					<section>
						<h2>이미지 로딩 이슈</h2>
						<p>데이터 요청 시점에 80개의 상품 이미지들 한번에 불러온다는 것</p>
						<p>페이지를 그려낸 뒤에도 연속적으로 네트워크 호출이 발생<br>로딩된 이미지가 배치되면서 리플로우(레이아웃) 발생</p>
						<p>리플로우: 노드의 크기, 위치가 변경되어<br>현재 레이아웃의 일부 또는 전체를 다시 계산하는 과정</p>
						<!-- <p>이미지가 필요한 순간에 불러오도록 개선</p> -->
						<!-- 이미지 로딩 시간 및 상품 이미지들이 추가되기 까지 시간이 올래 걸림 -->
						<!--
						사용자가 스크롤 이동 또는 상품을 좌우 스와이프로 탐색하는 행동을 하는 시점 -->

					</section>


					<section>
						<img src="img/no_lazyloading.png" alt="" width="80%">
					</section>


					<section>
						<h2>지연 로딩 (Lazy Loading)</h2>
						<!-- <p>지연 로딩은 필요한 시점에 실행되도록 동작을 뒤로 미루는 방법</p> -->
						<!-- <p>체감 속도를 향상</p> -->
						<!-- <p>페이지에 보이지도 않는 이미지를 미리 받아둘 필요가 없는 경우<br>이미지를 나중에 로드하는 방법</p> -->
						<p>이미지를 처음부터 불러오는 게 아니라<br>사용자가 스크롤을 해서 이미지 엘리먼트가 화면에 등장하는 순간 로딩 시작</p>
						<p>모든 이미지를 한번에 불러올 필요가 없어 성능 개선 유용</p>
						<p>IntersectionObserver API 사용</p>


						<!-- <p><a href="https://addyosmani.com/blog/lazy-loading/">참고 (네이티브 이미지 레이지 로딩)</a></p> -->
						<!--
						<pre><code class="js">
<img src="celebration.jpg" loading="lazy" alt="..." />
<iframe src="video-player.html" loading="lazy"></iframe>
                        </code></pre>
                    	-->
					</section>

					<section>
						<h2>이미지 지연 로딩 적용한 결과</h2>
						<img src="img/lazyloading.png" alt="" width="80%">
					</section>

					<section>
						<img src="img/no_lazyloading2.png" alt="" width="80%">
						<img src="img/lazyloading2.png" alt="" width="80%">
					</section>


					<!--
					<section>
						<h3>기본 마크업 구조</h3>
						<pre><code class="html">
<div id="_infinite_grid">
	<ul>
		<li data-page="1">
		    <div>test1</div>
		</li>
		<li data-page="1">
		    <div>test2</div>
		</li>
		....
	</ul>
</div>
                        </code></pre>
					</section>


					<section>
						<h3>스크립트</h3>
						<pre><code class="js">
var oInfiniteGrid = new ssg.View.infiniteGrid({
    nEndPage: 30
});

//상품 추가
oInfiniteGrid.on('fetchItems', function(nCurPage) {
	var oSelf = this;
    getMoreItem(nCurPage).done(function(html) {
        var aItems = $($.parseHTML(html)).filter('li.spc_item');
        oSelf.addItemList(aItems);
    }).fail(function(){
    	oSelf.finalData();
    });
});
                        </code></pre>
					</section>


					<section>
						<h3>뒤로가기</h3>
						<pre><code class="js">
var oInfinitePersist = oInfiniteGrid.oPersist;

if (oInfinitePersist.get('') !== null) {
	oInfiniteGrid.historyBack();
} else {
	oInfiniteGrid.firstRender();
}
                        </code></pre>
					</section>
					 -->

				</section>



				<section>
					<section>
						<h2>스켈레톤 스크린</h2>
					</section>

					<section>
						<h2>로딩 인디케이터</h2>

						<p>웹페이지를 그리기 전, 서버를 거치는 과정에서 유저, 상품, 주문 정보 등<br>데이터를 DB 또는 외부 API 호출</p>
						<p>웹브라우저는 데이터 로딩이 완료될 때까지 대기</p>

						<!-- 따라서 데이터 로딩 시간이 길어질수록 빈 화면이 노출되거나 현재 페이지에 멈춰있게 됩니다. -->



						<p>사용자에게 기다려 달라는 의미지만 텅빈 화면을 오래 봐야 하는 단점</p>
						<img src="img/ssg_loding.png" alt="" width="30%">
					</section>



					<section>
						<h2>스켈레톤 스크린</h2>
						<p>페이지의 뼈대에 해당하는 빈 레이아웃을 먼저 보여주고<br>데이터를 받는 대로 부분적으로 채워가는 방식</p>
						<!-- <p>"덜 지루하게" "좀 더 빨라 보이도록"하는 기법 중 하나</p> -->
					</section>

					<section>
						<p>YouTube, Facebook 화면 로드 상태</p>
						<img src="img/youtebe.png" alt="" width="70%" style="margin:0">
						<!-- <p>Facebook 뉴스피드 로드 상태</p> -->
						<img src="img/facebook.png" alt="" width="70%" style="margin:0">
					</section>


					<section>
						<h2>데이터 지연 로딩</h2>
						<p>가장 중요한 UI 영역을 먼저 제공하고,<br>중요도가 떨어지는 영역을 이후 제공해 체감 속도 향상</p>
						<p>지연이 필요한 영역의 데이터 호출 로직을 서버 controller에서 제거<br>클라이언트 단에서 필요한 시점에 API를 호출하는 방식으로 전환</p>
						<p>자연스러운 UX를 위해 지연되는 시간 동안 스켈레톤 스크린 적용</p>
					</section>

					<section>

						<iframe width="100%" height="500" src="https://jsfiddle.net/hohoya33/trgsmxbc/embedded/result,js,html,css/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>
					</section>
				</section>




				<section>
					<h1>감사합니다.</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>